// Generated by ReScript, PLEASE EDIT WITH CARE

import * as ColorTheory from "../core/ColorTheory.res.mjs";
import * as PaletteGenerator from "../core/PaletteGenerator.res.mjs";

var Process = {};

var Console = {};

var NodeJs = {
  Process: Process,
  Console: Console
};

function parseArgs() {
  var argv = process.argv;
  var args = argv.slice(2);
  var _i = 0;
  var _acc = {
    color: "#2563eb",
    mode: "corporate",
    output: "Preview",
    name: undefined,
    help: false
  };
  while(true) {
    var acc = _acc;
    var i = _i;
    if (i >= args.length) {
      return acc;
    }
    var match = args[i];
    if (match !== undefined) {
      switch (match) {
        case "--color" :
            var color = args[i + 1 | 0];
            if (color !== undefined) {
              _acc = {
                color: color,
                mode: acc.mode,
                output: acc.output,
                name: acc.name,
                help: acc.help
              };
              _i = i + 2 | 0;
              continue ;
            }
            _i = i + 1 | 0;
            continue ;
        case "--help" :
            _acc = {
              color: acc.color,
              mode: acc.mode,
              output: acc.output,
              name: acc.name,
              help: true
            };
            _i = i + 1 | 0;
            continue ;
        case "--mode" :
            var mode = args[i + 1 | 0];
            if (mode !== undefined) {
              var modeValue;
              switch (mode) {
                case "balanced" :
                    modeValue = "balanced";
                    break;
                case "minimal" :
                    modeValue = "minimal";
                    break;
                case "vibrant" :
                    modeValue = "vibrant";
                    break;
                default:
                  modeValue = "corporate";
              }
              _acc = {
                color: acc.color,
                mode: modeValue,
                output: acc.output,
                name: acc.name,
                help: acc.help
              };
              _i = i + 2 | 0;
              continue ;
            }
            _i = i + 1 | 0;
            continue ;
        case "--name" :
            var name = args[i + 1 | 0];
            if (name !== undefined) {
              _acc = {
                color: acc.color,
                mode: acc.mode,
                output: acc.output,
                name: name,
                help: acc.help
              };
              _i = i + 2 | 0;
              continue ;
            }
            _i = i + 1 | 0;
            continue ;
        case "--output" :
            var output = args[i + 1 | 0];
            if (output !== undefined) {
              var outputValue;
              switch (output) {
                case "css" :
                    outputValue = "CSS";
                    break;
                case "json" :
                    outputValue = "JSON";
                    break;
                case "tailwind" :
                    outputValue = "Tailwind";
                    break;
                default:
                  outputValue = "Preview";
              }
              _acc = {
                color: acc.color,
                mode: acc.mode,
                output: outputValue,
                name: acc.name,
                help: acc.help
              };
              _i = i + 2 | 0;
              continue ;
            }
            _i = i + 1 | 0;
            continue ;
        default:
          _i = i + 1 | 0;
          continue ;
      }
    } else {
      _i = i + 1 | 0;
      continue ;
    }
  };
}

function showHelp() {
  console.log("\nðŸŽ¨ Color Palette Generator CLI\n\nUsage: npm run palette -- [options]\n\nOptions:\n  --color <hex>     Brand color in hex format (default: #2563eb)\n  --mode <mode>     Palette generation mode:\n                    - corporate: Professional, accessible palette\n                    - vibrant: Rich, colorful palette with analogous colors\n                    - balanced: Complementary color harmony\n                    - minimal: Simple 5-color palette\n                    (default: corporate)\n  --output <format> Output format:\n                    - preview: Console color preview (default)\n                    - tailwind: Tailwind CSS configuration\n                    - css: CSS custom properties\n                    - json: JSON format\n  --name <name>     Color name for exports (default: brand)\n  --help            Show this help message\n\nExamples:\n  npm run palette -- --color \"#ff6b6b\" --mode vibrant\n  npm run palette -- --color \"#2563eb\" --output tailwind --name primary\n  npm run palette -- --color \"#059669\" --mode corporate --output css\n");
}

function ansiColor(hex, text) {
  var rgb = ColorTheory.Convert.hexToRgb(hex);
  if (rgb.TAG !== "Ok") {
    return text;
  }
  var rgb$1 = rgb._0;
  var r = rgb$1.r | 0;
  var g = rgb$1.g | 0;
  var b = rgb$1.b | 0;
  return "\\x1b[48;2;" + r.toString() + ";" + g.toString() + ";" + b.toString() + "m" + text + "\\x1b[0m";
}

function showPreview(palette) {
  console.log("\\nðŸŽ¨ Generated Color Palette\\n");
  console.log("Color Scale:");
  palette.scale.forEach(function (entry) {
        var colorBlock = ansiColor(entry.hex, "    ");
        var weight = entry.weight.toString();
        var contrast = entry.contrastWithWhite.toFixed(2);
        var aa = entry.meetsAA_onWhite ? "âœ“ AA" : "âœ— AA";
        var paddedWeight = weight.length === 2 ? weight + " " : weight + "  ";
        console.log(colorBlock + " " + paddedWeight + " " + entry.hex + " (" + contrast + " " + aa + ")");
      });
  var semantic = palette.semanticColors;
  if (semantic !== undefined) {
    console.log("\\nSemantic Colors:");
    var successHex = ColorTheory.Convert.toHex(semantic.success);
    var warningHex = ColorTheory.Convert.toHex(semantic.warning);
    var errorHex = ColorTheory.Convert.toHex(semantic.error);
    var infoHex = ColorTheory.Convert.toHex(semantic.info);
    console.log(ansiColor(successHex, "    ") + " Success " + successHex);
    console.log(ansiColor(warningHex, "    ") + " Warning " + warningHex);
    console.log(ansiColor(errorHex, "    ") + " Error   " + errorHex);
    console.log(ansiColor(infoHex, "    ") + " Info    " + infoHex);
  }
  console.log("");
}

function generateOutput(palette, format, colorName) {
  switch (format) {
    case "Tailwind" :
        var config = PaletteGenerator.Utils.toTailwindConfig(palette, colorName);
        console.log(config);
        return ;
    case "CSS" :
        var css = PaletteGenerator.Utils.toCssVariables(palette, colorName);
        console.log(css);
        return ;
    case "JSON" :
        var scaleJson = palette.scale.map(function (entry) {
              return {
                      weight: entry.weight,
                      hex: entry.hex,
                      contrast: {
                        white: entry.contrastWithWhite,
                        black: entry.contrastWithBlack
                      },
                      accessibility: {
                        aa_on_white: entry.meetsAA_onWhite,
                        aa_on_black: entry.meetsAA_onBlack
                      }
                    };
            });
        var semantic = palette.semanticColors;
        var semanticJson = semantic !== undefined ? ({
              success: ColorTheory.Convert.toHex(semantic.success),
              warning: ColorTheory.Convert.toHex(semantic.warning),
              error: ColorTheory.Convert.toHex(semantic.error),
              info: ColorTheory.Convert.toHex(semantic.info)
            }) : undefined;
        var paletteJson = {
          name: palette.name,
          baseColor: ColorTheory.Convert.toHex(palette.baseColor),
          scale: scaleJson,
          semanticColors: semanticJson
        };
        console.log(JSON.stringify(paletteJson, null, 2));
        return ;
    case "Preview" :
        return showPreview(palette);
    
  }
}

function main() {
  var args = parseArgs();
  if (args.help) {
    return showHelp();
  }
  var brandColor = ColorTheory.Utils.parse(args.color);
  if (brandColor !== undefined) {
    var match = args.mode;
    var palette = match === "vibrant" ? PaletteGenerator.Presets.vibrant(brandColor) : (
        match === "corporate" ? PaletteGenerator.Presets.corporate(brandColor) : (
            match === "balanced" ? PaletteGenerator.Presets.balanced(brandColor) : PaletteGenerator.Presets.minimal(brandColor)
          )
      );
    var name = args.name;
    var colorName = name !== undefined ? name : "brand";
    return generateOutput(palette, args.output, colorName);
  }
  console.error("Error: Invalid color format \"" + args.color + "\". Please use hex format like #ff6b6b");
  process.exit(1);
}

main();

var CT;

var PG;

export {
  CT ,
  PG ,
  NodeJs ,
  parseArgs ,
  showHelp ,
  ansiColor ,
  showPreview ,
  generateOutput ,
  main ,
}
/*  Not a pure module */
