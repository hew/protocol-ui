// Generated by ReScript, PLEASE EDIT WITH CARE

import * as ColorTheory from "./ColorTheory.res.mjs";
import * as Core__Array from "@rescript/core/src/Core__Array.res.mjs";

function mod_float(x, y) {
  return x - Math.floor(x / y) * y;
}

function generateWeights(steps) {
  if (steps <= 0) {
    return [];
  } else if (steps === 10) {
    return [
            50,
            100,
            200,
            300,
            400,
            500,
            600,
            700,
            800,
            900,
            950
          ];
  } else {
    return Core__Array.make(steps, 0).map(function (param, i) {
                var progress = i / (steps - 1 | 0);
                if (i === 0) {
                  return 50;
                } else if (i === (steps - 1 | 0)) {
                  return 950;
                } else {
                  return 50 + progress * 900 | 0;
                }
              });
  }
}

function generateLightnessCurve(baseLightness, steps) {
  return Core__Array.make(steps, 0).map(function (param, i) {
              var t = i / (steps - 1 | 0);
              if (t < 0.5) {
                var adjustedT = t * 2;
                return 95 - (95 - baseLightness) * adjustedT * adjustedT;
              }
              var adjustedT$1 = (t - 0.5) * 2;
              return baseLightness - baseLightness * Math.pow(adjustedT$1, 1.5);
            });
}

function generateMonochromatic(baseColor, steps) {
  var hsl = ColorTheory.Convert.toHsl(baseColor);
  var lightnessCurve = generateLightnessCurve(hsl.l, steps);
  return lightnessCurve.map(function (lightness) {
              return {
                      TAG: "HSL",
                      _0: {
                        h: hsl.h,
                        s: hsl.s,
                        l: lightness
                      }
                    };
            });
}

function generateRichMonochromatic(baseColor, steps) {
  var hsl = ColorTheory.Convert.toHsl(baseColor);
  var lightnessCurve = generateLightnessCurve(hsl.l, steps);
  return lightnessCurve.map(function (lightness, i) {
              var t = i / (steps - 1 | 0);
              var hueShift = t < 0.5 ? -5 * (0.5 - t) : 5 * (t - 0.5);
              var saturationMultiplier = t < 0.2 ? 0.3 + t * 3.5 : (
                  t > 0.8 ? 1 - (t - 0.8) * 2.5 : 1
                );
              return {
                      TAG: "HSL",
                      _0: {
                        h: mod_float(hsl.h + hueShift, 360),
                        s: Math.min(100, hsl.s * saturationMultiplier),
                        l: lightness
                      }
                    };
            });
}

function createScaleEntry(color, weight) {
  var contrastWithWhite = ColorTheory.Analyze.contrastRatio(color, {
        TAG: "RGB",
        _0: {
          r: 255,
          g: 255,
          b: 255
        }
      });
  var contrastWithBlack = ColorTheory.Analyze.contrastRatio(color, {
        TAG: "RGB",
        _0: {
          r: 0,
          g: 0,
          b: 0
        }
      });
  return {
          weight: weight,
          color: color,
          hex: ColorTheory.Convert.toHex(color),
          contrastWithWhite: contrastWithWhite,
          contrastWithBlack: contrastWithBlack,
          meetsAA_onWhite: contrastWithWhite >= 4.5,
          meetsAA_onBlack: contrastWithBlack >= 4.5
        };
}

var Scale = {
  generateWeights: generateWeights,
  generateLightnessCurve: generateLightnessCurve,
  generateMonochromatic: generateMonochromatic,
  generateRichMonochromatic: generateRichMonochromatic,
  createScaleEntry: createScaleEntry
};

function generateSuccess(baseColor) {
  var hsl = ColorTheory.Convert.toHsl(baseColor);
  var currentHue = hsl.h;
  var hueDiff = 120 - currentHue;
  var rotation = Math.abs(hueDiff) > 180 ? (
      hueDiff > 0 ? hueDiff - 360 : hueDiff + 360
    ) : hueDiff;
  var newHue = mod_float(currentHue + rotation * 0.8, 360);
  return {
          TAG: "HSL",
          _0: {
            h: newHue,
            s: Math.max(40, Math.min(70, hsl.s)),
            l: Math.max(35, Math.min(45, hsl.l))
          }
        };
}

function generateWarning(baseColor) {
  var hsl = ColorTheory.Convert.toHsl(baseColor);
  var currentHue = hsl.h;
  var hueDiff = 40 - currentHue;
  var rotation = Math.abs(hueDiff) > 180 ? (
      hueDiff > 0 ? hueDiff - 360 : hueDiff + 360
    ) : hueDiff;
  var newHue = mod_float(currentHue + rotation * 0.8, 360);
  return {
          TAG: "HSL",
          _0: {
            h: newHue,
            s: Math.max(60, Math.min(80, hsl.s)),
            l: Math.max(45, Math.min(55, hsl.l))
          }
        };
}

function generateError(baseColor) {
  var hsl = ColorTheory.Convert.toHsl(baseColor);
  var currentHue = hsl.h;
  var hueDiff = - currentHue;
  var rotation = Math.abs(hueDiff) > 180 ? (
      hueDiff > 0 ? hueDiff - 360 : hueDiff + 360
    ) : hueDiff;
  var newHue = mod_float(currentHue + rotation * 0.85, 360);
  return {
          TAG: "HSL",
          _0: {
            h: newHue,
            s: Math.max(55, Math.min(75, hsl.s)),
            l: Math.max(40, Math.min(50, hsl.l))
          }
        };
}

function generateInfo(baseColor) {
  var hsl = ColorTheory.Convert.toHsl(baseColor);
  var currentHue = hsl.h;
  var hueDiff = 220 - currentHue;
  var rotation = Math.abs(hueDiff) > 180 ? (
      hueDiff > 0 ? hueDiff - 360 : hueDiff + 360
    ) : hueDiff;
  var newHue = mod_float(currentHue + rotation * 0.75, 360);
  return {
          TAG: "HSL",
          _0: {
            h: newHue,
            s: Math.max(50, Math.min(70, hsl.s)),
            l: Math.max(40, Math.min(50, hsl.l))
          }
        };
}

function generateSemanticColors(baseColor) {
  return {
          success: generateSuccess(baseColor),
          warning: generateWarning(baseColor),
          error: generateError(baseColor),
          info: generateInfo(baseColor)
        };
}

var Semantic = {
  generateSuccess: generateSuccess,
  generateWarning: generateWarning,
  generateError: generateError,
  generateInfo: generateInfo,
  generateSemanticColors: generateSemanticColors
};

function generatePalette(config) {
  var weights = generateWeights(config.steps);
  var match = config.mode;
  var colorScale;
  if (match === "analogous") {
    ColorTheory.Harmony.analogous(config.baseColor, undefined);
    colorScale = generateRichMonochromatic(config.baseColor, weights.length);
  } else if (match === "monochromatic" || match === "triadic") {
    colorScale = generateRichMonochromatic(config.baseColor, weights.length);
  } else if (match === "custom") {
    colorScale = generateMonochromatic(config.baseColor, weights.length);
  } else {
    var complement = ColorTheory.Manipulate.complement(config.baseColor);
    colorScale = Core__Array.make(weights.length, 0).map(function (param, i) {
          var t = i / (weights.length - 1 | 0);
          var mixRatio = t * 0.1;
          return ColorTheory.Manipulate.darken(ColorTheory.Manipulate.lighten(ColorTheory.Manipulate.mix(config.baseColor, complement, mixRatio), (1 - t) * 45), t * 45);
        });
  }
  var scale = weights.map(function (weight, i) {
        var color = colorScale[i];
        if (color !== undefined) {
          return createScaleEntry(color, weight);
        } else {
          return createScaleEntry(config.baseColor, weight);
        }
      });
  var accessibleScale = config.preserveAccessibility ? scale.map(function (entry) {
          if (entry.weight <= 400 && !entry.meetsAA_onWhite) {
            var adjusted = ColorTheory.Manipulate.darken(entry.color, 5);
            return createScaleEntry(adjusted, entry.weight);
          }
          if (!(entry.weight >= 600 && !entry.meetsAA_onBlack)) {
            return entry;
          }
          var adjusted$1 = ColorTheory.Manipulate.lighten(entry.color, 5);
          return createScaleEntry(adjusted$1, entry.weight);
        }) : scale;
  var semanticColors = config.generateSemanticColors ? generateSemanticColors(config.baseColor) : undefined;
  var match$1 = config.mode;
  var complement$1 = match$1 === "complementary" ? ColorTheory.Manipulate.complement(config.baseColor) : undefined;
  var match$2 = config.mode;
  var analogous;
  if (match$2 === "analogous") {
    var colors = ColorTheory.Harmony.analogous(config.baseColor, undefined);
    var match$3 = colors[0];
    var match$4 = colors[2];
    analogous = match$3 !== undefined && match$4 !== undefined ? [
        match$3,
        match$4
      ] : undefined;
  } else {
    analogous = undefined;
  }
  return {
          name: "Generated Palette",
          baseColor: config.baseColor,
          scale: accessibleScale,
          semanticColors: semanticColors,
          complementary: complement$1,
          analogous: analogous
        };
}

function corporate(brandColor) {
  return generatePalette({
              baseColor: brandColor,
              mode: "monochromatic",
              steps: 11,
              preserveAccessibility: true,
              generateSemanticColors: true
            });
}

function vibrant(brandColor) {
  return generatePalette({
              baseColor: brandColor,
              mode: "analogous",
              steps: 11,
              preserveAccessibility: true,
              generateSemanticColors: true
            });
}

function balanced(brandColor) {
  return generatePalette({
              baseColor: brandColor,
              mode: "complementary",
              steps: 11,
              preserveAccessibility: true,
              generateSemanticColors: true
            });
}

function minimal(brandColor) {
  return generatePalette({
              baseColor: brandColor,
              mode: "monochromatic",
              steps: 5,
              preserveAccessibility: true,
              generateSemanticColors: false
            });
}

var Presets = {
  corporate: corporate,
  vibrant: vibrant,
  balanced: balanced,
  minimal: minimal
};

function toTailwindConfig(palette, colorName) {
  var scaleObject = palette.scale.map(function (entry) {
          return "'" + entry.weight.toString() + "': '" + entry.hex + "'";
        }).join(",\n        ");
  var semantic = palette.semanticColors;
  var semanticObject = semantic !== undefined ? ",\n      success: '" + ColorTheory.Convert.toHex(semantic.success) + "',\n      warning: '" + ColorTheory.Convert.toHex(semantic.warning) + "',\n      error: '" + ColorTheory.Convert.toHex(semantic.error) + "',\n      info: '" + ColorTheory.Convert.toHex(semantic.info) + "'" : "";
  return "colors: {\n      '" + colorName + "': {\n        " + scaleObject + semanticObject + "\n      }\n    }";
}

function toCssVariables(palette, prefix) {
  var scaleVars = palette.scale.map(function (entry) {
          return "  --" + prefix + "-" + entry.weight.toString() + ": " + entry.hex + ";";
        }).join("\n");
  var semantic = palette.semanticColors;
  var semanticVars = semantic !== undefined ? "\n  --" + prefix + "-success: " + ColorTheory.Convert.toHex(semantic.success) + ";\n  --" + prefix + "-warning: " + ColorTheory.Convert.toHex(semantic.warning) + ";\n  --" + prefix + "-error: " + ColorTheory.Convert.toHex(semantic.error) + ";\n  --" + prefix + "-info: " + ColorTheory.Convert.toHex(semantic.info) + ";" : "";
  return ":root {\n" + scaleVars + semanticVars + "\n}";
}

function getBestTextColor(backgroundColor, palette) {
  var entry = palette.scale[0];
  var lightOption = entry !== undefined ? entry.color : ({
        TAG: "RGB",
        _0: {
          r: 255,
          g: 255,
          b: 255
        }
      });
  var entry$1 = palette.scale[palette.scale.length - 1 | 0];
  var darkOption = entry$1 !== undefined ? entry$1.color : ({
        TAG: "RGB",
        _0: {
          r: 0,
          g: 0,
          b: 0
        }
      });
  var lightContrast = ColorTheory.Analyze.contrastRatio(backgroundColor, lightOption);
  var darkContrast = ColorTheory.Analyze.contrastRatio(backgroundColor, darkOption);
  if (darkContrast >= lightContrast && darkContrast >= 4.5) {
    return darkOption;
  }
  if (lightContrast >= 4.5) {
    return lightOption;
  }
  var blackContrast = ColorTheory.Analyze.contrastRatio(backgroundColor, {
        TAG: "RGB",
        _0: {
          r: 0,
          g: 0,
          b: 0
        }
      });
  var whiteContrast = ColorTheory.Analyze.contrastRatio(backgroundColor, {
        TAG: "RGB",
        _0: {
          r: 255,
          g: 255,
          b: 255
        }
      });
  if (whiteContrast >= blackContrast) {
    return {
            TAG: "RGB",
            _0: {
              r: 255,
              g: 255,
              b: 255
            }
          };
  } else {
    return {
            TAG: "RGB",
            _0: {
              r: 0,
              g: 0,
              b: 0
            }
          };
  }
}

var Utils = {
  toTailwindConfig: toTailwindConfig,
  toCssVariables: toCssVariables,
  getBestTextColor: getBestTextColor
};

var CT;

export {
  CT ,
  mod_float ,
  Scale ,
  Semantic ,
  generatePalette ,
  Presets ,
  Utils ,
}
/* No side effect */
