// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Core__Array from "@rescript/core/src/Core__Array.res.mjs";

function mod_float(x, y) {
  return x - Math.floor(x / y) * y;
}

function clamp(value, min, max) {
  return Math.max(min, Math.min(max, value));
}

function hexToRgb(hex) {
  var cleanHex = hex.startsWith("#") ? hex.slice(1) : hex;
  if (cleanHex.length !== 6) {
    return {
            TAG: "Error",
            _0: "Invalid hex color length"
          };
  }
  var parseInt16 = (function(str) { 
        const result = parseInt(str, 16);
        return isNaN(result) ? undefined : result;
      });
  var match = parseInt16(cleanHex.slice(0, 2));
  var match$1 = parseInt16(cleanHex.slice(2, 4));
  var match$2 = parseInt16(cleanHex.slice(4, 6));
  if (match !== undefined && match$1 !== undefined && match$2 !== undefined) {
    return {
            TAG: "Ok",
            _0: {
              r: Caml_option.valFromOption(match),
              g: Caml_option.valFromOption(match$1),
              b: Caml_option.valFromOption(match$2)
            }
          };
  } else {
    return {
            TAG: "Error",
            _0: "Invalid hex color format"
          };
  }
}

function rgbToHex(rgb) {
  var toHexComponent = function (value) {
    var intValue = clamp(value, 0, 255) | 0;
    var hex = intValue.toString(16);
    if (hex.length === 1) {
      return "0" + hex;
    } else {
      return hex;
    }
  };
  return "#" + toHexComponent(rgb.r) + toHexComponent(rgb.g) + toHexComponent(rgb.b);
}

function rgbToHsl(rgb) {
  var r = rgb.r / 255;
  var g = rgb.g / 255;
  var b = rgb.b / 255;
  var max = Math.max(r, Math.max(g, b));
  var min = Math.min(r, Math.min(g, b));
  var delta = max - min;
  var l = (max + min) / 2;
  if (delta === 0) {
    return {
            h: 0,
            s: 0,
            l: l * 100
          };
  }
  var s = delta / (1 - Math.abs(2 * l - 1));
  var h = max === r ? mod_float((g - b) / delta + (
          g < b ? 6 : 0
        ), 6) : (
      max === g ? (b - r) / delta + 2 : (r - g) / delta + 4
    );
  return {
          h: h * 60,
          s: s * 100,
          l: l * 100
        };
}

function hslToRgb(hsl) {
  var h = hsl.h / 360;
  var s = hsl.s / 100;
  var l = hsl.l / 100;
  if (s === 0) {
    var gray = l * 255;
    return {
            r: gray,
            g: gray,
            b: gray
          };
  }
  var hue2rgb = function (p, q, t) {
    var t$1 = mod_float(t, 1);
    if (t$1 < 1 / 6) {
      return p + (q - p) * 6 * t$1;
    } else if (t$1 < 1 / 2) {
      return q;
    } else if (t$1 < 2 / 3) {
      return p + (q - p) * (2 / 3 - t$1) * 6;
    } else {
      return p;
    }
  };
  var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
  var p = 2 * l - q;
  return {
          r: hue2rgb(p, q, h + 1 / 3) * 255,
          g: hue2rgb(p, q, h) * 255,
          b: hue2rgb(p, q, h - 1 / 3) * 255
        };
}

function rgbToHsv(rgb) {
  var r = rgb.r / 255;
  var g = rgb.g / 255;
  var b = rgb.b / 255;
  var max = Math.max(r, Math.max(g, b));
  var min = Math.min(r, Math.min(g, b));
  var delta = max - min;
  var s = max === 0 ? 0 : delta / max;
  var h = delta === 0 ? 0 : (
      max === r ? mod_float((g - b) / delta + (
              g < b ? 6 : 0
            ), 6) : (
          max === g ? (b - r) / delta + 2 : (r - g) / delta + 4
        )
    );
  return {
          h: h * 60,
          s: s * 100,
          v: max * 100
        };
}

function hsvToRgb(hsv) {
  var h = hsv.h / 60;
  var s = hsv.s / 100;
  var v = hsv.v / 100;
  var c = v * s;
  var x = c * (1 - Math.abs(mod_float(h, 2) - 1));
  var m = v - c;
  var match = h < 1 ? [
      c,
      x,
      0
    ] : (
      h < 2 ? [
          x,
          c,
          0
        ] : (
          h < 3 ? [
              0,
              c,
              x
            ] : (
              h < 4 ? [
                  0,
                  x,
                  c
                ] : (
                  h < 5 ? [
                      x,
                      0,
                      c
                    ] : [
                      c,
                      0,
                      x
                    ]
                )
            )
        )
    );
  return {
          r: (match[0] + m) * 255,
          g: (match[1] + m) * 255,
          b: (match[2] + m) * 255
        };
}

function toRgb(color) {
  switch (color.TAG) {
    case "RGB" :
        return color._0;
    case "HSL" :
        return hslToRgb(color._0);
    case "HSV" :
        return hsvToRgb(color._0);
    case "LAB" :
        return {
                r: 0,
                g: 0,
                b: 0
              };
    case "Hex" :
        var rgb = hexToRgb(color._0);
        if (rgb.TAG === "Ok") {
          return rgb._0;
        } else {
          return {
                  r: 0,
                  g: 0,
                  b: 0
                };
        }
    
  }
}

function toHsl(color) {
  switch (color.TAG) {
    case "RGB" :
        return rgbToHsl(color._0);
    case "HSL" :
        return color._0;
    case "HSV" :
        return rgbToHsl(hsvToRgb(color._0));
    case "LAB" :
        return {
                h: 0,
                s: 0,
                l: 0
              };
    case "Hex" :
        var rgb = hexToRgb(color._0);
        if (rgb.TAG === "Ok") {
          return rgbToHsl(rgb._0);
        } else {
          return {
                  h: 0,
                  s: 0,
                  l: 0
                };
        }
    
  }
}

function toHex(color) {
  switch (color.TAG) {
    case "RGB" :
        return rgbToHex(color._0);
    case "HSL" :
        return rgbToHex(hslToRgb(color._0));
    case "HSV" :
        return rgbToHex(hsvToRgb(color._0));
    case "LAB" :
        return "#000000";
    case "Hex" :
        var hex = color._0;
        if (hex.startsWith("#")) {
          return hex;
        } else {
          return "#" + hex;
        }
    
  }
}

var Convert = {
  mod_float: mod_float,
  clamp: clamp,
  hexToRgb: hexToRgb,
  rgbToHex: rgbToHex,
  rgbToHsl: rgbToHsl,
  hslToRgb: hslToRgb,
  rgbToHsv: rgbToHsv,
  hsvToRgb: hsvToRgb,
  toRgb: toRgb,
  toHsl: toHsl,
  toHex: toHex
};

function lighten(color, amount) {
  var hsl = toHsl(color);
  var newL = Math.min(100, hsl.l + amount);
  return {
          TAG: "HSL",
          _0: {
            h: hsl.h,
            s: hsl.s,
            l: newL
          }
        };
}

function darken(color, amount) {
  var hsl = toHsl(color);
  var newL = Math.max(0, hsl.l - amount);
  return {
          TAG: "HSL",
          _0: {
            h: hsl.h,
            s: hsl.s,
            l: newL
          }
        };
}

function saturate(color, amount) {
  var hsl = toHsl(color);
  var newS = Math.min(100, hsl.s + amount);
  return {
          TAG: "HSL",
          _0: {
            h: hsl.h,
            s: newS,
            l: hsl.l
          }
        };
}

function desaturate(color, amount) {
  var hsl = toHsl(color);
  var newS = Math.max(0, hsl.s - amount);
  return {
          TAG: "HSL",
          _0: {
            h: hsl.h,
            s: newS,
            l: hsl.l
          }
        };
}

function rotate(color, degrees) {
  var hsl = toHsl(color);
  var newH = (hsl.h + degrees) % 360;
  return {
          TAG: "HSL",
          _0: {
            h: newH,
            s: hsl.s,
            l: hsl.l
          }
        };
}

function mix(color1, color2, ratio) {
  var rgb1 = toRgb(color1);
  var rgb2 = toRgb(color2);
  var ratio$1 = clamp(ratio, 0, 1);
  return {
          TAG: "RGB",
          _0: {
            r: rgb1.r * (1 - ratio$1) + rgb2.r * ratio$1,
            g: rgb1.g * (1 - ratio$1) + rgb2.g * ratio$1,
            b: rgb1.b * (1 - ratio$1) + rgb2.b * ratio$1
          }
        };
}

function grayscale(color) {
  var hsl = toHsl(color);
  return {
          TAG: "HSL",
          _0: {
            h: hsl.h,
            s: 0,
            l: hsl.l
          }
        };
}

function invert(color) {
  var rgb = toRgb(color);
  return {
          TAG: "RGB",
          _0: {
            r: 255 - rgb.r,
            g: 255 - rgb.g,
            b: 255 - rgb.b
          }
        };
}

function complement(color) {
  return rotate(color, 180);
}

var Manipulate = {
  lighten: lighten,
  darken: darken,
  saturate: saturate,
  desaturate: desaturate,
  rotate: rotate,
  mix: mix,
  grayscale: grayscale,
  invert: invert,
  complement: complement
};

function relativeLuminance(color) {
  var rgb = toRgb(color);
  var toLinear = function (value) {
    var v = value / 255;
    if (v <= 0.03928) {
      return v / 12.92;
    } else {
      return Math.pow((v + 0.055) / 1.055, 2.4);
    }
  };
  var r = toLinear(rgb.r);
  var g = toLinear(rgb.g);
  var b = toLinear(rgb.b);
  return 0.2126 * r + 0.7152 * g + 0.0722 * b;
}

function contrastRatio(color1, color2) {
  var lum1 = relativeLuminance(color1);
  var lum2 = relativeLuminance(color2);
  var lighter = Math.max(lum1, lum2);
  var darker = Math.min(lum1, lum2);
  return (lighter + 0.05) / (darker + 0.05);
}

function meetsWCAG_AA(color1, color2, largeTextOpt) {
  var largeText = largeTextOpt !== undefined ? largeTextOpt : false;
  var ratio = contrastRatio(color1, color2);
  if (largeText) {
    return ratio >= 3.0;
  } else {
    return ratio >= 4.5;
  }
}

function meetsWCAG_AAA(color1, color2, largeTextOpt) {
  var largeText = largeTextOpt !== undefined ? largeTextOpt : false;
  var ratio = contrastRatio(color1, color2);
  if (largeText) {
    return ratio >= 4.5;
  } else {
    return ratio >= 7.0;
  }
}

function isLight(color) {
  return relativeLuminance(color) > 0.5;
}

function perceivedBrightness(color) {
  var rgb = toRgb(color);
  return Math.sqrt(0.299 * rgb.r * rgb.r + 0.587 * rgb.g * rgb.g + 0.114 * rgb.b * rgb.b);
}

var Analyze = {
  relativeLuminance: relativeLuminance,
  contrastRatio: contrastRatio,
  meetsWCAG_AA: meetsWCAG_AA,
  meetsWCAG_AAA: meetsWCAG_AAA,
  isLight: isLight,
  perceivedBrightness: perceivedBrightness
};

function analogous(color, angleOpt) {
  var angle = angleOpt !== undefined ? angleOpt : 30;
  return [
          rotate(color, - angle),
          color,
          rotate(color, angle)
        ];
}

function triadic(color) {
  return [
          color,
          rotate(color, 120),
          rotate(color, 240)
        ];
}

function tetradic(color) {
  return [
          color,
          rotate(color, 90),
          rotate(color, 180),
          rotate(color, 270)
        ];
}

function splitComplementary(color, angleOpt) {
  var angle = angleOpt !== undefined ? angleOpt : 30;
  return [
          color,
          rotate(color, 180 - angle),
          rotate(color, 180 + angle)
        ];
}

function monochromatic(color, stepsOpt) {
  var steps = stepsOpt !== undefined ? stepsOpt : 5;
  var hsl = toHsl(color);
  var stepSize = 100 / (steps + 1 | 0);
  return Core__Array.make(steps, 0).map(function (param, i) {
              var lightness = stepSize * (i + 1 | 0);
              return {
                      TAG: "HSL",
                      _0: {
                        h: hsl.h,
                        s: hsl.s,
                        l: lightness
                      }
                    };
            });
}

var Harmony = {
  analogous: analogous,
  triadic: triadic,
  tetradic: tetradic,
  splitComplementary: splitComplementary,
  monochromatic: monochromatic
};

function parse(colorString) {
  var trimmed = colorString.trim();
  if (trimmed.startsWith("#") || trimmed.length === 6) {
    return {
            TAG: "Hex",
            _0: trimmed
          };
  }
  
}

function toCssString(color) {
  switch (color.TAG) {
    case "RGB" :
        var rgb = color._0;
        return "rgb(" + (rgb.r | 0).toString() + ", " + (rgb.g | 0).toString() + ", " + (rgb.b | 0).toString() + ")";
    case "HSL" :
        var hsl = color._0;
        return "hsl(" + (hsl.h | 0).toString() + ", " + (hsl.s | 0).toString() + "%, " + (hsl.l | 0).toString() + "%)";
    case "HSV" :
    case "LAB" :
        return toHex(color);
    case "Hex" :
        var hex = color._0;
        if (hex.startsWith("#")) {
          return hex;
        } else {
          return "#" + hex;
        }
    
  }
}

function fromRgb(r, g, b) {
  return {
          TAG: "RGB",
          _0: {
            r: clamp(r, 0, 255),
            g: clamp(g, 0, 255),
            b: clamp(b, 0, 255)
          }
        };
}

function fromHsl(h, s, l) {
  return {
          TAG: "HSL",
          _0: {
            h: h % 360,
            s: clamp(s, 0, 100),
            l: clamp(l, 0, 100)
          }
        };
}

var Utils = {
  parse: parse,
  toCssString: toCssString,
  fromRgb: fromRgb,
  fromHsl: fromHsl
};

export {
  Convert ,
  Manipulate ,
  Analyze ,
  Harmony ,
  Utils ,
}
/* No side effect */
